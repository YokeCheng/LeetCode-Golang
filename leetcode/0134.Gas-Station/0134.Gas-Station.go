package leetcode

//贪心解法：
//时间复杂度：
//该解法只需一次遍历加油站，因此时间复杂度为 O(n)，其中 n 是加油站的数量。

//空间复杂度：
//该解法的空间复杂度为 O(1)，因为它只使用了恒定数量的额外空间用于变量，与输入规模无关。
//从时间复杂度的角度来看，优化的贪心解法更为高效，因为它只需要一次遍历加油站。此外，两种解法的空间复杂度相同，因为它们只使用了恒定数量的额外空间用于变量。

// 通过遍历每个加油站，累计总的加油量和消耗量，以及计算从起始站到当前站点的剩余油量。
// 如果在某个站点剩余油量为负，说明从之前的起始站出发无法到达当前站点，因此将起始站点设置为下一个站点，并重置当前油量。
// 最后，如果总加油量小于总消耗量，则无法绕一圈，否则返回起始站点的索引。
func canCompleteCircuit(gas []int, cost []int) int {
	currentSum, currentGas, startIndex := 0, 0, 0

	for i := 0; i < len(gas); i++ {
		currentSum += gas[i] - cost[i] // 累加总的消耗量
		currentGas += gas[i] - cost[i] // 更新当前剩余的油量，表示从起始站到当前站的油量剩余

		if currentGas < 0 { // 如果当前油量为负，无法前往下一站
			currentGas = 0     // 重置当前油量
			startIndex = i + 1 // 尝试从下一站出发
		}
	}

	if currentSum < 0 { // 如果总加油量小于总消耗量，无法绕一圈
		return -1
	}

	return startIndex // 返回起始站点的索引
}

// 时间复杂度：
//外部循环运行了 n 次，其中 n 是加油站的数量。
//内部循环最多运行了 n 次，但由于 break 条件的存在，平均情况下运行次数会较少。
//因此，最坏情况下的时间复杂度为 O(n^2)，其中 n 是加油站的数量。

//空间复杂度：
//该解法的空间复杂度为 O(1)，因为它只使用了恒定数量的额外空间用于变量，与输入规模无关。
func canCompleteCircuit1(gas []int, cost []int) int {
	for i, n := 0, len(gas); i < n; { // 遍历所有加油站
		sumOfGas, sumOfCost, cnt := 0, 0, 0 // 初始化当前起始站的加油量、消耗以及计数器
		for cnt < n {                       // 在当前起始站尝试循环
			j := (i + cnt) % n        // 获取当前循环内的站点索引
			sumOfGas += gas[j]        // 累加当前站点的加油量
			sumOfCost += cost[j]      // 累加当前站点的消耗
			if sumOfCost > sumOfGas { // 如果消耗大于加油量，无法前往下一站
				break // 退出循环
			}
			cnt++ // 前往下一站
		}
		if cnt == n { // 如果循环次数等于加油站总数
			return i // 返回起始站索引，表示可以环绕一周
		} else { // 否则无法从当前站点出发，尝试下一个站点
			i += cnt + 1
		}
	}
	return -1 // 如果无法找到符合条件的起始站，则返回-1
}
